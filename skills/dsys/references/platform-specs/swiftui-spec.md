# SwiftUI Platform Output Specification

**Version:** 1.0
**Target:** SwiftUI, iOS 16 minimum
**Generator:** Direct Claude output (no Style Dictionary — Swift files generated from design-system.json directly)

---

## 1. Overview

This spec defines every file the SwiftUI generator must produce when given a validated `design-system.json`. The minimum iOS target is **iOS 16**. The generator reads `.dsys/design-system.json` and writes files into the target project.

The generator must produce files that a developer can drop directly into an Xcode project or Swift Package and use immediately — no manual editing required. Every file in this manifest is required; none are optional.

**Input:** `.dsys/design-system.json` (validated against `design-system.schema.json`)
**Output root:** configurable, defaults to `./DesignSystem/`

**Why direct generation (not Style Dictionary):** Style Dictionary's SwiftUI output requires Swift Package tooling and custom formatters that add significant setup friction. Claude generates Swift files directly from `design-system.json`, which is simpler, more readable, and produces output tailored to the specific tokens in the design system.

**iOS 16 baseline APIs used:**
- `Color("name", bundle: .module)` — iOS 14+
- `@ScaledMetric` — iOS 14+
- `NavigationStack` — iOS 16+
- `#Preview` macro — Xcode 15+, but compiles against iOS 16 deployment target

---

## 2. File Manifest

| File | Purpose | Required |
|------|---------|----------|
| `DesignSystem/Colors+DesignSystem.swift` | Color token extensions | Yes |
| `DesignSystem/Typography+DesignSystem.swift` | Font/Typography extensions | Yes |
| `DesignSystem/Spacing+DesignSystem.swift` | Spacing constants with `@ScaledMetric` | Yes |
| `DesignSystem/Radius+DesignSystem.swift` | Border radius constants | Yes |
| `DesignSystem/Shadows+DesignSystem.swift` | Shadow style ViewModifier | Yes |
| `DesignSystem/Colors.xcassets/` | Asset catalog with color sets (light + dark per token) | Yes |
| `DesignSystem/Components/DSButton.swift` | Button component | Yes |
| `DesignSystem/Components/DSCard.swift` | Card surface container | Yes |
| `DesignSystem/Components/DSInput.swift` | Input/TextField component | Yes |
| `DesignSystem/Components/DSBadge.swift` | Badge/tag component | Yes |
| `DesignSystem/Components/DSHeading.swift` | Heading text component | Yes |
| `DesignSystem/Components/DSText.swift` | Body text component | Yes |

All 12 entries must be present for the generator output to be considered complete. Note that `Colors.xcassets/` is a directory, not a single file — it contains one `.colorset` per semantic color token.

---

## 3. `Colors+DesignSystem.swift` Spec

**Purpose:** A `public extension` on `Color` that provides static properties for each semantic color token. Components import SwiftUI and reference `Color.dsActionPrimary` directly.

**Critical requirement:** Color properties must use `Color("tokenName", bundle: .module)` — **never** a custom `Color(hex:)` initializer. The asset catalog pattern enables automatic light/dark mode adaptation by the OS. Raw hex values cannot switch with the color scheme.

**Token naming convention:** `ds` prefix + PascalCase role. Examples:
- `dsActionPrimary` (not `actionPrimary`, not `primaryColor`, not `blue`)
- `dsSurfaceDefault` (not `surface`, not `background`)
- `dsTextPrimary` (not `textColor`, not `primaryText`)

**Complete example:**

```swift
// Colors+DesignSystem.swift
// Generated by dsys — do not edit manually

import SwiftUI

public extension Color {
    // ── Action tokens ──
    static let dsActionPrimary     = Color("dsActionPrimary",     bundle: .module)
    static let dsActionSecondary   = Color("dsActionSecondary",   bundle: .module)
    static let dsActionDestructive = Color("dsActionDestructive", bundle: .module)

    // ── Surface tokens ──
    static let dsSurfaceDefault    = Color("dsSurfaceDefault",    bundle: .module)
    static let dsSurfaceRaised     = Color("dsSurfaceRaised",     bundle: .module)
    static let dsSurfaceOverlay    = Color("dsSurfaceOverlay",    bundle: .module)
    static let dsSurfaceInset      = Color("dsSurfaceInset",      bundle: .module)

    // ── Text tokens ──
    static let dsTextPrimary       = Color("dsTextPrimary",       bundle: .module)
    static let dsTextSecondary     = Color("dsTextSecondary",     bundle: .module)
    static let dsTextMuted         = Color("dsTextMuted",         bundle: .module)
    static let dsTextInverse       = Color("dsTextInverse",       bundle: .module)
    static let dsTextLink          = Color("dsTextLink",          bundle: .module)

    // ── Border tokens ──
    static let dsBorderDefault     = Color("dsBorderDefault",     bundle: .module)
    static let dsBorderFocus       = Color("dsBorderFocus",       bundle: .module)

    // ── Feedback tokens ──
    static let dsFeedbackSuccess   = Color("dsFeedbackSuccess",   bundle: .module)
    static let dsFeedbackError     = Color("dsFeedbackError",     bundle: .module)
    static let dsFeedbackWarning   = Color("dsFeedbackWarning",   bundle: .module)
    static let dsFeedbackInfo      = Color("dsFeedbackInfo",      bundle: .module)
}
```

---

## 4. `Colors.xcassets/` Spec

**Purpose:** Asset catalog providing light and dark color variants for every semantic color token. The OS selects the correct variant automatically based on the current color scheme.

**Directory structure:**

```
DesignSystem/Colors.xcassets/
├── Contents.json                            ← top-level catalog manifest
├── dsActionPrimary.colorset/
│   └── Contents.json                        ← light + dark sRGB values
├── dsActionSecondary.colorset/
│   └── Contents.json
├── dsActionDestructive.colorset/
│   └── Contents.json
├── dsSurfaceDefault.colorset/
│   └── Contents.json
├── dsSurfaceRaised.colorset/
│   └── Contents.json
... (one .colorset per semantic color token)
```

**Top-level `Colors.xcassets/Contents.json`:**

```json
{
  "info": {
    "version": 1,
    "author": "xcode"
  }
}
```

**Per-colorset `Contents.json` structure:**

Color values are in the **sRGB color space** with `red`, `green`, `blue`, and `alpha` as decimal strings in the range `0.000` to `1.000` (three decimal places).

Conversion: `decimal = hex_component / 255`. Example: `#3B82F6` → red = `59/255 = 0.231`, green = `130/255 = 0.510`, blue = `246/255 = 0.965`.

```json
{
  "colors": [
    {
      "color": {
        "color-space": "srgb",
        "components": {
          "red":   "0.231",
          "green": "0.510",
          "blue":  "0.965",
          "alpha": "1.000"
        }
      },
      "idiom": "universal"
    },
    {
      "appearances": [
        {
          "appearance": "luminosity",
          "value": "dark"
        }
      ],
      "color": {
        "color-space": "srgb",
        "components": {
          "red":   "0.114",
          "green": "0.306",
          "blue":  "0.847",
          "alpha": "1.000"
        }
      },
      "idiom": "universal"
    }
  ],
  "info": {
    "version": 1,
    "author": "xcode"
  }
}
```

The first entry (no `appearances` key) is the **universal/light** value. The second entry (with `appearances: luminosity/dark`) is the **dark mode** value.

**Generator requirement:** The generator must produce one `.colorset` directory for every semantic color token in `design-system.json`. The `Contents.json` file name must be exactly `Contents.json` (capital C). The `.colorset` directory name must exactly match the `Color(...)` string literal used in `Colors+DesignSystem.swift`.

---

## 5. `Typography+DesignSystem.swift` Spec

**Purpose:** Provides design-system font access via a `DSFont` namespace. Components use `DSFont.heading1()`, `DSFont.body()`, etc.

**Pattern:** Static functions (not properties) to allow future parameterization. Use `.custom("FontName", size: N, relativeTo: .textStyle)` for custom fonts — the `relativeTo:` parameter enables Dynamic Type scaling for the custom font relative to the nearest system text style.

If `font_family.sans` is `null` in the design system (no custom font detected), fall back to `.system(size: N, weight: .regular, design: .default)` for the appropriate text style.

```swift
// Typography+DesignSystem.swift
// Generated by dsys — do not edit manually

import SwiftUI

public struct DSFont {
    private init() {}

    // ── Display / Heading ──
    public static func display() -> Font {
        // Replace "Inter" with the font family from design-system.json
        // If no custom font: .largeTitle
        .custom("Inter", size: 48, relativeTo: .largeTitle)
    }

    public static func heading1() -> Font {
        .custom("Inter", size: 36, relativeTo: .largeTitle)
    }

    public static func heading2() -> Font {
        .custom("Inter", size: 30, relativeTo: .title)
    }

    public static func heading3() -> Font {
        .custom("Inter", size: 24, relativeTo: .title2)
    }

    public static func heading4() -> Font {
        .custom("Inter", size: 20, relativeTo: .title3)
    }

    // ── Body ──
    public static func bodyLarge() -> Font {
        .custom("Inter", size: 18, relativeTo: .body)
    }

    public static func body() -> Font {
        .custom("Inter", size: 16, relativeTo: .body)
    }

    public static func bodySmall() -> Font {
        .custom("Inter", size: 14, relativeTo: .callout)
    }

    // ── Supporting ──
    public static func caption() -> Font {
        .custom("Inter", size: 12, relativeTo: .caption)
    }

    public static func label() -> Font {
        .custom("Inter", size: 13, relativeTo: .caption2)
    }

    // ── Monospace ──
    public static func code() -> Font {
        // Replace "JetBrains Mono" with font_family.mono from design-system.json
        // If null: .system(size: 14, design: .monospaced)
        .custom("JetBrains Mono", size: 14, relativeTo: .body)
    }
}
```

**Usage in components:** `.font(DSFont.body())` — not `.font(.body)` (which uses the system default, bypassing the design system).

---

## 6. `Spacing+DesignSystem.swift` Spec

**Purpose:** Spacing constants aligned with the design system's spacing scale (4px grid).

**Critical requirement:** Use `@ScaledMetric` for Dynamic Type support. `@ScaledMetric` is a property wrapper — it requires instance properties, not static properties or stored constants.

**Pattern:** A `public struct DSSpacing` with instance `@ScaledMetric` properties, plus a static shared instance for view code that needs static access. Views that want Dynamic Type-aware spacing should use `@ScaledMetric` directly or create a local `DSSpacing()` instance.

```swift
// Spacing+DesignSystem.swift
// Generated by dsys — do not edit manually

import SwiftUI

public struct DSSpacing {
    @ScaledMetric(relativeTo: .body) public var xs:  CGFloat = 4
    @ScaledMetric(relativeTo: .body) public var sm:  CGFloat = 8
    @ScaledMetric(relativeTo: .body) public var md:  CGFloat = 16
    @ScaledMetric(relativeTo: .body) public var lg:  CGFloat = 24
    @ScaledMetric(relativeTo: .body) public var xl:  CGFloat = 32
    @ScaledMetric(relativeTo: .body) public var xxl: CGFloat = 48

    public init() {}
}

// Convenience: fixed (non-scaling) values for layout that should not grow with text size
public enum DSSpacingFixed {
    public static let xs:  CGFloat = 4
    public static let sm:  CGFloat = 8
    public static let md:  CGFloat = 16
    public static let lg:  CGFloat = 24
    public static let xl:  CGFloat = 32
    public static let xxl: CGFloat = 48
}
```

**Usage in components:**

```swift
// Dynamic Type-aware (recommended for padding/gap inside components)
private var spacing = DSSpacing()

var body: some View {
    VStack(spacing: spacing.md) {
        // ...
    }
    .padding(spacing.md)
}

// Fixed spacing (for layout constraints that should not scale)
.frame(height: DSSpacingFixed.xl)
```

---

## 7. `Radius+DesignSystem.swift` Spec

**Purpose:** Border radius constants. Static values — radii typically do not need Dynamic Type scaling.

```swift
// Radius+DesignSystem.swift
// Generated by dsys — do not edit manually

import SwiftUI

public enum DSRadius {
    public static let none:   CGFloat = 0
    public static let sm:     CGFloat = 4
    public static let md:     CGFloat = 8
    public static let lg:     CGFloat = 12
    public static let xl:     CGFloat = 16
    public static let full:   CGFloat = 9999
}
```

**Usage:** `.clipShape(RoundedRectangle(cornerRadius: DSRadius.md))`

---

## 8. `Shadows+DesignSystem.swift` Spec

**Purpose:** Shadow styles as a `ViewModifier` pattern, applied via a `View` extension for ergonomic call-site syntax.

```swift
// Shadows+DesignSystem.swift
// Generated by dsys — do not edit manually

import SwiftUI

public enum DSShadowSize { case sm, md, lg }

struct DSShadowModifier: ViewModifier {
    let size: DSShadowSize

    func body(content: Content) -> some View {
        switch size {
        case .sm:
            content.shadow(color: .black.opacity(0.05), radius: 1, x: 0, y: 1)
        case .md:
            content.shadow(color: .black.opacity(0.1), radius: 6, x: 0, y: 4)
        case .lg:
            content.shadow(color: .black.opacity(0.1), radius: 15, x: 0, y: 10)
        }
    }
}

public extension View {
    func dsShadow(_ size: DSShadowSize = .md) -> some View {
        modifier(DSShadowModifier(size: size))
    }
}
```

**Usage:** `.dsShadow(.md)` applied to any `View`.

**Generator note:** The shadow values (opacity, radius, x, y) must be derived from `design-system.json`'s `tokens.shadow` array. If `tokens.shadow` is `null` in the design system, the generator should emit the default values shown above as a reasonable baseline.

---

## 9. Component Template Spec

All component files must:

- Be prefixed with `DS` to avoid conflicts with SwiftUI built-in views (e.g., `DSButton` not `Button`)
- Use only design system tokens for colors (`Color.dsActionPrimary`), spacing (`DSSpacing`, `DSSpacingFixed`), radius (`DSRadius`), and fonts (`DSFont.*`)
- **Never** use raw hex values, system color names (`Color.blue`), or magic numbers for spacing
- Include a `#Preview` block for Xcode canvas preview
- Be marked `public` for use as a Swift Package

### DSButton (`Components/DSButton.swift`)

Purpose: Primary interactive action element. Three variants × three sizes.

```swift
// DSButton.swift — generated by dsys

import SwiftUI

public struct DSButton: View {
    public enum Variant { case primary, secondary, destructive }
    public enum Size { case sm, md, lg }

    let title: String
    let variant: Variant
    let size: Size
    let action: () -> Void

    public init(
        _ title: String,
        variant: Variant = .primary,
        size: Size = .md,
        action: @escaping () -> Void
    ) {
        self.title = title
        self.variant = variant
        self.size = size
        self.action = action
    }

    private var spacing = DSSpacing()

    public var body: some View {
        Button(action: action) {
            Text(title)
                .font(labelFont)
                .fontWeight(.medium)
                .padding(.horizontal, horizontalPadding)
                .padding(.vertical, verticalPadding)
        }
        .foregroundStyle(foregroundColor)
        .background(backgroundColor)
        .clipShape(RoundedRectangle(cornerRadius: cornerRadius))
    }

    private var foregroundColor: Color {
        switch variant {
        case .primary:     return .dsTextInverse
        case .secondary:   return .dsTextPrimary
        case .destructive: return .dsTextInverse
        }
    }

    private var backgroundColor: Color {
        switch variant {
        case .primary:     return .dsActionPrimary
        case .secondary:   return .dsSurfaceRaised
        case .destructive: return .dsActionDestructive
        }
    }

    private var labelFont: Font {
        switch size {
        case .sm: return DSFont.bodySmall()
        case .md: return DSFont.body()
        case .lg: return DSFont.bodyLarge()
        }
    }

    private var horizontalPadding: CGFloat {
        switch size {
        case .sm: return DSSpacingFixed.sm + DSSpacingFixed.xs  // 12
        case .md: return DSSpacingFixed.md                      // 16
        case .lg: return DSSpacingFixed.lg                      // 24
        }
    }

    private var verticalPadding: CGFloat {
        switch size {
        case .sm: return DSSpacingFixed.xs + 2                  // 6
        case .md: return DSSpacingFixed.sm                      // 8
        case .lg: return DSSpacingFixed.sm + DSSpacingFixed.xs  // 12
        }
    }

    private var cornerRadius: CGFloat {
        switch size {
        case .sm: return DSRadius.sm
        case .md: return DSRadius.md
        case .lg: return DSRadius.md
        }
    }
}

#Preview {
    VStack(spacing: 16) {
        HStack(spacing: 8) {
            DSButton("Primary") {}
            DSButton("Secondary", variant: .secondary) {}
            DSButton("Danger", variant: .destructive) {}
        }
        HStack(spacing: 8) {
            DSButton("Small", size: .sm) {}
            DSButton("Medium") {}
            DSButton("Large", size: .lg) {}
        }
    }
    .padding()
    .background(Color.dsSurfaceDefault)
}
```

### DSCard (`Components/DSCard.swift`)

Purpose: Elevated surface container for grouping related content.

```swift
// DSCard.swift — generated by dsys

import SwiftUI

public struct DSCard<Content: View>: View {
    let content: Content

    public init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    private var spacing = DSSpacing()

    public var body: some View {
        content
            .padding(spacing.md)
            .background(Color.dsSurfaceRaised)
            .clipShape(RoundedRectangle(cornerRadius: DSRadius.lg))
            .overlay(
                RoundedRectangle(cornerRadius: DSRadius.lg)
                    .stroke(Color.dsBorderDefault, lineWidth: 1)
            )
            .dsShadow(.sm)
    }
}

#Preview {
    DSCard {
        VStack(alignment: .leading, spacing: 8) {
            Text("Card title")
                .font(DSFont.heading4())
                .foregroundStyle(Color.dsTextPrimary)
            Text("Supporting card content goes here.")
                .font(DSFont.body())
                .foregroundStyle(Color.dsTextMuted)
        }
    }
    .padding()
    .background(Color.dsSurfaceDefault)
}
```

### DSInput (`Components/DSInput.swift`)

Purpose: Text input field with consistent focus ring and error state.

```swift
// DSInput.swift — generated by dsys

import SwiftUI

public struct DSInput: View {
    let placeholder: String
    @Binding var text: String
    var isError: Bool

    @FocusState private var isFocused: Bool
    private var spacing = DSSpacing()

    public init(_ placeholder: String, text: Binding<String>, isError: Bool = false) {
        self.placeholder = placeholder
        self._text = text
        self.isError = isError
    }

    public var body: some View {
        TextField(placeholder, text: $text)
            .font(DSFont.body())
            .foregroundStyle(Color.dsTextPrimary)
            .padding(.horizontal, spacing.md)
            .padding(.vertical, spacing.sm)
            .background(Color.dsSurfaceInset)
            .clipShape(RoundedRectangle(cornerRadius: DSRadius.md))
            .overlay(
                RoundedRectangle(cornerRadius: DSRadius.md)
                    .stroke(borderColor, lineWidth: isFocused ? 2 : 1)
            )
            .focused($isFocused)
    }

    private var borderColor: Color {
        if isError { return .dsFeedbackError }
        if isFocused { return .dsBorderFocus }
        return .dsBorderDefault
    }
}

#Preview {
    @State var text = ""
    @State var errorText = "invalid@"

    return VStack(spacing: 16) {
        DSInput("Email address", text: $text)
        DSInput("Invalid input", text: $errorText, isError: true)
    }
    .padding()
    .background(Color.dsSurfaceDefault)
}
```

### DSBadge (`Components/DSBadge.swift`)

Purpose: Inline status label for categories, tags, and state indicators.

```swift
// DSBadge.swift — generated by dsys

import SwiftUI

public struct DSBadge: View {
    public enum Variant { case `default`, success, error, warning, info }

    let label: String
    let variant: Variant

    public init(_ label: String, variant: Variant = .default) {
        self.label = label
        self.variant = variant
    }

    public var body: some View {
        Text(label)
            .font(DSFont.label())
            .fontWeight(.medium)
            .foregroundStyle(foregroundColor)
            .padding(.horizontal, DSSpacingFixed.sm + DSSpacingFixed.xs)  // 12
            .padding(.vertical, DSSpacingFixed.xs / 2)                    // 2
            .background(backgroundColor)
            .clipShape(Capsule())
            .overlay(Capsule().stroke(borderColor, lineWidth: 1))
    }

    private var foregroundColor: Color {
        switch variant {
        case .default: return .dsTextMuted
        case .success: return .dsFeedbackSuccess
        case .error:   return .dsFeedbackError
        case .warning: return .dsFeedbackWarning
        case .info:    return .dsFeedbackInfo
        }
    }

    private var backgroundColor: Color {
        switch variant {
        case .default: return .dsSurfaceInset
        case .success: return .dsFeedbackSuccess.opacity(0.1)
        case .error:   return .dsFeedbackError.opacity(0.1)
        case .warning: return .dsFeedbackWarning.opacity(0.1)
        case .info:    return .dsFeedbackInfo.opacity(0.1)
        }
    }

    private var borderColor: Color {
        switch variant {
        case .default: return .dsBorderDefault
        case .success: return .dsFeedbackSuccess.opacity(0.2)
        case .error:   return .dsFeedbackError.opacity(0.2)
        case .warning: return .dsFeedbackWarning.opacity(0.2)
        case .info:    return .dsFeedbackInfo.opacity(0.2)
        }
    }
}

#Preview {
    HStack(spacing: 8) {
        DSBadge("Default")
        DSBadge("Success", variant: .success)
        DSBadge("Error", variant: .error)
        DSBadge("Warning", variant: .warning)
        DSBadge("Info", variant: .info)
    }
    .padding()
    .background(Color.dsSurfaceDefault)
}
```

### DSHeading (`Components/DSHeading.swift`)

Purpose: Semantic heading text at each level of the type hierarchy.

```swift
// DSHeading.swift — generated by dsys

import SwiftUI

public struct DSHeading: View {
    public enum Level { case h1, h2, h3, h4 }

    let text: String
    let level: Level

    public init(_ text: String, level: Level = .h1) {
        self.text = text
        self.level = level
    }

    public var body: some View {
        Text(text)
            .font(headingFont)
            .fontWeight(fontWeight)
            .foregroundStyle(Color.dsTextPrimary)
            .lineSpacing(2)
    }

    private var headingFont: Font {
        switch level {
        case .h1: return DSFont.heading1()
        case .h2: return DSFont.heading2()
        case .h3: return DSFont.heading3()
        case .h4: return DSFont.heading4()
        }
    }

    private var fontWeight: Font.Weight {
        switch level {
        case .h1, .h2: return .bold
        case .h3, .h4: return .semibold
        }
    }
}

#Preview {
    VStack(alignment: .leading, spacing: 16) {
        DSHeading("Heading 1")
        DSHeading("Heading 2", level: .h2)
        DSHeading("Heading 3", level: .h3)
        DSHeading("Heading 4", level: .h4)
    }
    .padding()
    .background(Color.dsSurfaceDefault)
}
```

### DSText (`Components/DSText.swift`)

Purpose: Body text and inline content using the type scale and semantic text colors.

```swift
// DSText.swift — generated by dsys

import SwiftUI

public struct DSText: View {
    public enum Variant { case primary, secondary, muted }
    public enum Size { case sm, base, lg }

    let content: String
    let variant: Variant
    let size: Size

    public init(_ content: String, variant: Variant = .primary, size: Size = .base) {
        self.content = content
        self.variant = variant
        self.size = size
    }

    public var body: some View {
        Text(content)
            .font(textFont)
            .foregroundStyle(foregroundColor)
            .lineSpacing(4)
    }

    private var textFont: Font {
        switch size {
        case .sm:   return DSFont.bodySmall()
        case .base: return DSFont.body()
        case .lg:   return DSFont.bodyLarge()
        }
    }

    private var foregroundColor: Color {
        switch variant {
        case .primary:   return .dsTextPrimary
        case .secondary: return .dsTextSecondary
        case .muted:     return .dsTextMuted
        }
    }
}

#Preview {
    VStack(alignment: .leading, spacing: 12) {
        DSText("Primary text at base size")
        DSText("Secondary text at base size", variant: .secondary)
        DSText("Muted caption text", variant: .muted, size: .sm)
        DSText("Large body text", size: .lg)
    }
    .padding()
    .background(Color.dsSurfaceDefault)
}
```

---

## 10. Naming Conventions

| Concern | Convention | Example |
|---------|-----------|---------|
| Color extension properties | `ds` prefix + PascalCase role | `dsActionPrimary`, `dsSurfaceDefault` |
| Spacing/Font/Radius structs | `DS` prefix | `DSSpacing`, `DSFont`, `DSRadius` |
| Component views | `DS` prefix (avoids SwiftUI name conflicts) | `DSButton`, `DSCard`, `DSInput` |
| Asset catalog colorset names | camelCase matching the `Color(...)` string | `dsActionPrimary.colorset` |
| File names | Match the type/extension name | `Colors+DesignSystem.swift`, `DSButton.swift` |
| Enum variants | lowercase for value types, `DS` prefix for types | `.primary`, `.sm`, `DSShadowSize.md` |

**Collision avoidance:** The `DS` prefix for component names is non-negotiable. SwiftUI has `Button`, `Text`, `Image`, `Label` — using the same name causes ambiguity at the call site and requires import qualifications. `DSButton`, `DSText`, `DSCard` are always unambiguous.

---

## 11. "Done" Checklist

The generator output is complete when all of the following are true:

- [ ] All `.swift` files compile without errors against iOS 16 deployment target (no iOS 17+ API usage)
- [ ] Colors reference the asset catalog via `Color("name", bundle: .module)` — no `Color(hex:)`, no `UIColor(red:green:blue:alpha:)`, no hardcoded `Color(.sRGB, red:green:blue:opacity:)`
- [ ] `Spacing+DesignSystem.swift` uses instance `@ScaledMetric` properties (not static properties) in `DSSpacing`
- [ ] All 6 component files exist in `DesignSystem/Components/` and each includes a `#Preview` block
- [ ] `Colors.xcassets/` contains one `.colorset` directory per semantic color token with a properly-formed `Contents.json` (both universal/light and luminosity/dark appearances)
- [ ] All components use only design system tokens — no `Color.blue`, no `Font.body`, no magic number spacing
- [ ] A developer can copy the `DesignSystem/` folder into an Xcode project or add it as a local Swift Package dependency and use `DSButton("Tap me") {}` immediately without any additional configuration
