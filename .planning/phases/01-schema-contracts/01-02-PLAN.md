---
phase: 01-schema-contracts
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/dsys/references/token-schema.md
  - skills/dsys/schemas/design-system.schema.json
autonomous: true
requirements:
  - ORCH-04

must_haves:
  truths:
    - "The design-system.json JSON Schema validates a conformant design system document"
    - "The design-system.json JSON Schema rejects output missing required fields"
    - "The design-system.json schema supports theme-aware color tokens with light/dark values without duplicating the token set"
    - "The design-system.json schema uses W3C DTCG format with $value, $type, and $description fields"
    - "The design-system.json schema includes a conflict_log for recording synthesis decisions"
  artifacts:
    - path: "skills/dsys/references/token-schema.md"
      provides: "Human-readable spec of design-system.json with rationale"
      contains: "DTCG"
    - path: "skills/dsys/schemas/design-system.schema.json"
      provides: "Machine-readable JSON Schema 2020-12 for design-system.json"
      contains: "$schema"
  key_links:
    - from: "skills/dsys/references/token-schema.md"
      to: "skills/dsys/schemas/design-system.schema.json"
      via: "Human-readable spec mirrors the machine-readable schema"
      pattern: "design-system"
    - from: "skills/dsys/schemas/design-system.schema.json"
      to: "skills/dsys/schemas/analysis-findings.schema.json"
      via: "Design system schema consumes and restructures the data defined in analysis findings"
      pattern: "color"
---

<objective>
Create the canonical design-system.json contract: the human-readable token schema spec and the machine-readable JSON Schema that validates the synthesizer's output.

Purpose: The synthesizer (Phase 3) merges N analysis findings into a single design-system.json. Without a strict schema, the synthesizer output would vary in structure, causing generator failures in Phase 4. This schema is also the intermediate artifact that decouples analysis from generation (ORCH-03).

Output: Two files — `token-schema.md` (human-readable spec with rationale and examples) and `design-system.schema.json` (JSON Schema 2020-12).
</objective>

<execution_context>
@/Users/james/.claude/get-shit-done/workflows/execute-plan.md
@/Users/james/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-schema-contracts/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create design-system.json human-readable spec</name>
  <files>
    skills/dsys/references/token-schema.md
  </files>
  <action>
Create `skills/dsys/references/token-schema.md` — the human-readable specification of `design-system.json`.

Structure the document as follows:

1. **Overview** section explaining that design-system.json is the intermediate artifact between analysis and generation. It uses W3C DTCG format (`$value`, `$type`, `$description`). It is written to disk at `.dsys/design-system.json` and is human-inspectable before generators run.

2. **Top-Level Structure** section describing the four required top-level keys:
   - `meta`: Generation metadata, source information, aesthetic summary, conflict log
   - `tokens`: The actual design tokens in DTCG format
   - `aesthetic`: Synthesized aesthetic identity
   - `platform_notes`: Per-platform hints for generators

3. **`meta` Object** section with field-by-field documentation:
   - `generated_at` (string, ISO 8601 datetime)
   - `source_count` (integer, total benchmark images analyzed)
   - `source_types` (object: `{ ui_screenshots: int, visual_references: int }`)
   - `aesthetic_summary` (string, 2-3 sentences summarizing the dominant aesthetic)
   - `dominant_approach` (string, e.g. "Clean SaaS with blue accent" or "Bold editorial with dramatic contrast")
   - `conflict_log` (array of `{ token, candidates, chosen, rationale }` — always present, empty array if no conflicts)

4. **`tokens` Object** section with subsections for each token category:

   **`tokens.color`** — Two-layer architecture:
   - `tokens.color.primitive`: Raw color values with no semantic meaning. Grouped by hue family. Each token: `{ "$value": "#RRGGBB", "$type": "color" }`. Group-level `$type` inheritance.
   - `tokens.color.semantic`: Role-based tokens referencing primitives. Each token: `{ "$value": { "light": "{primitive.color.X}", "dark": "{primitive.color.Y}" }, "$type": "color", "$description": "..." }`. Document the full semantic taxonomy (action.primary, action.secondary, action.destructive, surface.default, surface.raised, surface.overlay, surface.inset, text.primary, text.secondary, text.muted, text.inverse, text.link, border.default, border.focus, feedback.success, feedback.error, feedback.warning, feedback.info).
   - Explain the theme-aware `$value` pattern: semantic color `$value` is an object `{ "light": "...", "dark": "..." }` using DTCG reference syntax for references to primitives, or raw hex for direct values.

   **`tokens.typography`**:
   - `font_family`: object with `sans`, `mono`, `display` keys. Each: `{ "$value": "Font Name", "$type": "fontFamily", "fallback_stack": ["fallback1", "fallback2"] }`.
   - `scale`: object with size tier keys (xs, sm, base, lg, xl, 2xl, 3xl, 4xl, 5xl). Each: `{ "$value": "Npx", "$type": "dimension" }`.
   - `weight`: object with weight tier keys (regular, medium, semibold, bold). Each: `{ "$value": N, "$type": "fontWeight" }`.
   - `line_height`: object with `tight`, `normal`, `relaxed`, `loose` keys. Each: `{ "$value": N, "$type": "number" }` (unitless multiplier).

   **`tokens.spacing`**:
   - `base_unit`: number (4 or 8)
   - `scale`: object with numeric keys (1, 2, 3, 4, 5, 6, 8, 10, 12, 16, 20, 24, 32). Each: `{ "$value": "Npx", "$type": "dimension" }`.
   - `semantic`: object with named spacing tokens (component-gap, section-padding, page-margin, input-padding, card-padding, stack-gap). Each: `{ "$value": "{spacing.N}", "$type": "dimension", "$description": "..." }`.

   **`tokens.shadow`**: array or null. Each: `{ "$value": { "offsetX": "Npx", "offsetY": "Npx", "blur": "Npx", "spread": "Npx", "color": "#RRGGBBAA" }, "$type": "shadow", "elevation": "sm|md|lg|xl" }`.

   **`tokens.border_radius`**: object with sm, md, lg, full keys. Each: `{ "$value": "Npx", "$type": "dimension" }`. `full` uses `"9999px"`.

   **`tokens.opacity`**: object with named keys (subtle, disabled, overlay, heavy). Each: `{ "$value": N, "$type": "number" }`.

5. **`aesthetic` Object** section:
   - `summary` (string, 2-3 sentences)
   - `personality_tags` (array of 4-8 strings)
   - `density` (enum: compact/comfortable/spacious)
   - `tone` (enum: minimal/expressive/corporate/playful/bold/elegant)

6. **`platform_notes` Object** section:
   - `react` (string, hints for React/Tailwind generation)
   - `swiftui` (string, hints for SwiftUI generation)

7. **Complete Example** section with a full design-system.json example showing all sections populated with realistic values. This example serves as the fill-in template for the synthesizer agent prompt.

8. **Design Rationale** section explaining:
   - Why two-layer (primitive + semantic) for colors
   - Why theme-aware `$value` as an object instead of separate files
   - Why `conflict_log` is required (transparency in synthesis decisions)
   - Why DTCG format (tooling compatibility, future-proofing)
  </action>
  <verify>
    The file exists and contains all 8 sections. The semantic color taxonomy lists all 18 roles. The complete example is valid JSON (can be extracted and parsed). The theme-aware $value pattern is demonstrated with both reference syntax and raw hex.
  </verify>
  <done>
    A comprehensive human-readable specification exists for design-system.json that a synthesizer agent can follow to produce correctly structured output. It includes a complete example that doubles as a fill-in template.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create design-system.json JSON Schema 2020-12</name>
  <files>
    skills/dsys/schemas/design-system.schema.json
  </files>
  <action>
Create `skills/dsys/schemas/design-system.schema.json` — a valid JSON Schema 2020-12 document.

Use the schema excerpt from the research document as a starting point, but expand it to be complete and precise:

1. **Root object**: `required: ["meta", "tokens", "aesthetic", "platform_notes"]`

2. **`meta` object**: `required: ["generated_at", "source_count", "source_types", "aesthetic_summary", "dominant_approach", "conflict_log"]`
   - `generated_at`: `{ "type": "string", "format": "date-time" }`
   - `source_count`: `{ "type": "integer", "minimum": 1 }`
   - `source_types`: object with `ui_screenshots` (integer >= 0) and `visual_references` (integer >= 0)
   - `aesthetic_summary`: `{ "type": "string", "minLength": 20 }` (enforce meaningful content)
   - `dominant_approach`: `{ "type": "string", "minLength": 10 }`
   - `conflict_log`: array of objects, each with required `token` (string), `candidates` (array of strings, minItems: 2), `chosen` (string), `rationale` (string)

3. **`tokens` object**: `required: ["color", "typography", "spacing", "shadow", "border_radius", "opacity"]`

   **`tokens.color`**: object with `required: ["primitive", "semantic"]`
   - `primitive`: object with `additionalProperties` allowing nested color groups. Define a `$defs` section with a `colorToken` definition: object with required `$value` (string, pattern `^#[0-9A-Fa-f]{6}$`) and `$type` (const: "color"), optional `$description` (string).
   - `semantic`: object with `additionalProperties` allowing nested semantic groups. Define a `semanticColorToken` definition: object with required `$value` (oneOf: string for non-themed, or object with required `light` and `dark` string properties for themed), `$type` (const: "color"), `$description` (string).

   **`tokens.typography`**: `required: ["font_family", "scale", "weight", "line_height"]`
   - `font_family`: object, properties `sans`, `mono`, `display` each as `["object", "null"]` where the object has `$value` (string), `$type` (const: "fontFamily"), optional `fallback_stack` (array of strings).
   - `scale`: object with additionalProperties of dimension token objects (`$value` string, `$type` const "dimension").
   - `weight`: object with additionalProperties of fontWeight token objects (`$value` number, `$type` const "fontWeight").
   - `line_height`: object with additionalProperties of number token objects (`$value` number, `$type` const "number").

   **`tokens.spacing`**: `required: ["base_unit", "scale"]`
   - `base_unit`: `{ "type": "number", "enum": [4, 8] }`
   - `scale`: object with additionalProperties of dimension tokens
   - `semantic`: object (optional) with additionalProperties of dimension tokens with `$description`

   **`tokens.shadow`**: `type: ["array", "null"]`. Items: shadow token with `$value` object (required: offsetX, offsetY, blur, spread as strings, color as string), `$type` (const: "shadow"), `elevation` (enum: sm/md/lg/xl).

   **`tokens.border_radius`**: object with properties sm, md, lg, full as dimension tokens.

   **`tokens.opacity`**: `type: ["object", "null"]`. Properties as number tokens.

4. **`aesthetic` object**: `required: ["summary", "personality_tags", "density", "tone"]`
   - `summary`: string
   - `personality_tags`: array of strings, minItems: 4, maxItems: 8
   - `density`: enum: compact/comfortable/spacious
   - `tone`: enum: minimal/expressive/corporate/playful/bold/elegant

5. **`platform_notes` object**: properties `react` and `swiftui` as strings.

6. **`$defs` section**: Define reusable schema fragments for `colorToken`, `semanticColorToken`, `dimensionToken`, `shadowValue`, `fontWeightToken`, `numberToken` to avoid repetition in the schema.

Validate the final JSON by parsing it.
  </action>
  <verify>
    The file exists and is valid JSON (`node -e "JSON.parse(require('fs').readFileSync('skills/dsys/schemas/design-system.schema.json', 'utf8'))"`). The schema has `$schema: "https://json-schema.org/draft/2020-12/schema"`. The root `required` array contains `meta`, `tokens`, `aesthetic`, `platform_notes`. The `tokens.color` section supports both flat string and `{ light, dark }` object `$value` types. A `$defs` section exists with reusable schema fragments.
  </verify>
  <done>
    A valid JSON Schema 2020-12 file exists that validates design-system.json output from the synthesizer. It supports the two-layer color architecture, theme-aware $value objects, DTCG format throughout, and a required conflict_log. Reusable schema fragments in $defs prevent repetition.
  </done>
</task>

</tasks>

<verification>
1. Both files exist under `skills/dsys/`
2. The JSON Schema file is valid JSON
3. The token-schema.md documents all token categories: color (primitive + semantic), typography, spacing, shadow, border_radius, opacity
4. The design-system.schema.json supports theme-aware color tokens with `oneOf` for flat string vs `{ light, dark }` object
5. The conflict_log is a required field in meta (can be empty array but must be present)
6. The token naming uses DTCG `$value`, `$type`, `$description` throughout
7. The complete example in token-schema.md would validate against design-system.schema.json
</verification>

<success_criteria>
- The design-system.json JSON Schema validates a conformant design system document with all token categories populated
- The design-system.json JSON Schema rejects output missing required top-level keys
- Theme-aware color tokens with `{ light, dark }` $value objects are supported without requiring separate token files
- The conflict_log is enforced as a required array (never absent)
- The human-readable spec includes a complete fill-in example that matches the schema
</success_criteria>

<output>
After completion, create `.planning/phases/01-schema-contracts/01-02-SUMMARY.md`
</output>
