---
phase: 03-synthesizer-agent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - skills/dsys/agents/synthesizer.md
autonomous: true
requirements:
  - SYNTH-01
  - SYNTH-02
  - SYNTH-03
  - ORCH-03

must_haves:
  truths:
    - "A schema-conformant synthesizer agent prompt exists that can be invoked by the orchestrator via Task"
    - "The agent reads N analysis findings files and produces a single design-system.json"
    - "The agent applies a multi-pass merge algorithm with explicit conflict resolution rules"
    - "The agent quantizes hex values before comparison to prevent false conflicts from rendering noise"
    - "The agent logs every multi-source conflict resolution decision in the conflict_log as it makes each decision (derived tokens are documented via $description, not conflict_log)"
    - "The agent writes its output to a caller-specified file path using the Write tool"
    - "The agent derives missing tokens (surface.overlay, surface.inset, text.secondary, text.link) from available data"
    - "The agent picks the dominant aesthetic direction, it does not blend mixed inputs"
  artifacts:
    - path: "skills/dsys/agents/synthesizer.md"
      provides: "Multi-finding synthesis agent prompt with embedded merge algorithm and output template"
      min_lines: 600
  key_links:
    - from: "skills/dsys/agents/synthesizer.md"
      to: "skills/dsys/references/token-schema.md"
      via: "Verbatim embedding of design-system.json fill-in template"
      pattern: "meta.*tokens.*aesthetic.*platform_notes"
    - from: "skills/dsys/agents/synthesizer.md"
      to: "skills/dsys/schemas/design-system.schema.json"
      via: "Output must conform to this schema"
      pattern: "design-system.schema.json"
    - from: "skills/dsys/agents/synthesizer.md"
      to: "skills/dsys/schemas/analysis-findings.schema.json"
      via: "Input files conform to this schema"
      pattern: "analysis-findings"
---

<objective>
Write the synthesizer agent prompt that reads N analysis findings JSON files and produces a single design-system.json conformant to the Phase 1 schema. The agent embeds the complete merge algorithm (quantization, frequency-weighted voting, tiebreaking, conflict logging), the semantic color derivation table, dark-mode inference heuristics, and the fill-in output template from token-schema.md.

Purpose: This is the core deliverable of Phase 3 — the Markdown agent prompt file that Claude uses to merge multiple benchmark analysis findings into a canonical design system. The synthesizer is the bridge between per-image analysis (Phase 2) and platform generation (Phase 4).

Output: One file — `skills/dsys/agents/synthesizer.md`
</objective>

<execution_context>
@/Users/james/.claude/get-shit-done/workflows/execute-plan.md
@/Users/james/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/02-analysis-agent/02-01-SUMMARY.md
@.planning/phases/03-synthesizer-agent/03-CONTEXT.md
@.planning/phases/03-synthesizer-agent/03-RESEARCH.md

@skills/dsys/references/token-schema.md
@skills/dsys/references/analysis-findings-schema.md
@skills/dsys/schemas/design-system.schema.json
@skills/dsys/schemas/analysis-findings.schema.json
@skills/dsys/agents/analyzer.md
@.dsys/findings/test-validation.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write the synthesizer agent prompt</name>
  <files>
    skills/dsys/agents/synthesizer.md
  </files>
  <action>
Create `skills/dsys/agents/synthesizer.md` — the multi-finding synthesis agent. This file IS the prompt. It will be invoked by the orchestrator via Task(agent: "skills/dsys/agents/synthesizer.md", prompt: "...").

Follow the established agent file anatomy from Phase 2 (analyzer.md): frontmatter + role + input + ordered steps + embedded template. The synthesizer has a different structure — merge algorithm instead of extraction rubric, and the output template comes from token-schema.md instead of analysis-findings-schema.md.

Structure the agent prompt in these exact sections, in this order:

**1. Agent Header**
```markdown
---
name: dsys-synthesizer
description: Merges N analysis findings into a single design-system.json with a coherent aesthetic identity. Reads per-image findings files, applies frequency-weighted merge algorithm with conflict logging, writes the canonical design system.
tools: Read, Write
---
```

**2. Role** — One paragraph: "You are the dsys synthesizer agent. You read N analysis findings JSON files (one per benchmark image from the analyzer agent) and produce a single design-system.json conformant to the design-system schema. You apply the merge algorithm below mechanically — do not improvise merge decisions."

**3. Input** — Explain that the agent receives:
- `findings_paths`: List of file paths to analysis findings JSON files (e.g., [".dsys/findings/bench-1.json", ".dsys/findings/bench-2.json"])
- `output_path`: Where to write design-system.json (default: ".dsys/design-system.json" if not provided)

**4. Step 1: Load All Findings** — For each path in findings_paths:
1. Use the Read tool to load the file.
2. If Read fails: skip this file and note it as a load failure in a running list.
3. Parse the JSON content.
Continue only if at least one findings file loaded successfully. If zero files loaded, STOP and return exactly: `"Error: No findings files could be loaded: [list of paths]"`

**5. Step 2: Source Validation Pass** — Count findings by image_type. Identify the DOMINANT BENCHMARK using the explicit selection rule from research:
1. Among ui_screenshot findings, rank by confidence ("high" > "medium" > "low").
2. Tiebreak: count non-null values in semantic_assignments. Higher count wins.
3. If no ui_screenshots: use the visual_reference with the most primitive_palette entries.
The dominant benchmark is the base for all token categories.

**6. Step 3: Color Quantization Rule** — Embed the quantization rule BEFORE any merge steps. Round each R, G, B channel independently to the nearest multiple of 16. Use quantized values ONLY for grouping/comparison. Write raw hex values to output, never quantized values. Include the concrete examples from the research (showing #1a73e8 and #1b74e9 grouping together, but #3B82F6 and #2563EB remaining distinct).

**7. Step 4: Semantic Color Merge Pass** — For EACH of the 21 semantic assignment keys:
1. Collect all non-null values from all findings.
2. Quantize all values.
3. Group by quantized bucket. Count each group.
4. If all non-null values quantize to the same bucket: no conflict. Use modal raw hex from the winning group.
5. If groups differ: CONFLICT.
   a. The largest group's modal raw hex wins.
   b. Tie: use the value from the dominant benchmark. If dominant is null, use the next-largest group's modal raw hex.
   c. **IMMEDIATELY** add a conflict_log entry: `{ "token": "tokens.color.semantic.{path}", "candidates": [all raw values], "chosen": "{winner}", "rationale": "{N}/{total} benchmarks" }`
6. If all values are null: derive a default using the Derivation Table below. Do NOT add a conflict_log entry for derived tokens — derivations are not conflicts. Instead, document the derivation in the token's `$description` field (e.g., `$description: "Derived: midpoint between text.primary and text.muted"`).

Include the COMPLETE findings-to-output MAPPING TABLE (all 21 keys → design-system.json paths, exactly as documented in the research Pattern 6).

Include the DERIVATION TABLE for tokens missing from findings:
- `surface.overlay`: surface.default lightened, or white for light / gray.800 for dark
- `surface.inset`: surface.default darkened by ~5% lightness (light: gray.100-equivalent / dark: gray.800-equivalent)
- `text.secondary`: midpoint between text.primary and text.muted
- `text.link`: same as action.primary

Include DARK-MODE DERIVATION HEURISTICS for when `_dark` keys are null:
- `action_primary_dark`: If light value has L* < 50, use a lighter version of same hue. If bright, darken slightly.
- `surface_default_dark`: Invert lightness, preserve hue undertone. Light near-white → dark near-black with same tint.
- `surface_raised_dark`: Slightly lighter than surface.default dark.
- `text_primary_dark`: Near-white on dark surface, preserve hue undertone from light value.
- `text_muted_dark`: Slightly lighter/darker than muted light to maintain contrast on dark surface.
- `text_inverse`: Keep same — typically white regardless of theme.
- `border_default` dark: Lighter than surface.default dark (equivalent of gray.700).
- `border_focus` dark: Same as action.primary dark.
- `feedback_*_dark`: Slightly lighter/more saturated version of light feedback color for dark backgrounds.

**8. Step 5: Primitive Color Build Pass** — Start with the dominant benchmark's primitive_palette. For each other finding's primitive_palette:
  - Quantize each color.
  - If the quantized value is NOT already in the dominant palette's bucket set AND the color appears in that finding's semantic_assignments: add it as a new entry.
  - Discard colors that quantize to an already-occupied bucket (they are the same color with rendering noise).
  - Group into hue families by HSL hue angle: blue (200-260), gray (any with S<10%), red (340-20), green (80-160), yellow/amber (40-80), purple (260-340), white (L>95%), black (L<10%).
  - For each hue family that appears in the semantic layer, produce 2-4 shades (e.g., 400/500/600 or 50/100/200/300/etc for neutrals).
  - The primitive layer must include ALL colors referenced by the semantic layer. Every hex used in semantic `$value` light/dark must exist as a primitive token or be a raw hex in the semantic `$value`.

**9. Step 6: Typography Merge Pass** — Font families: Use dominant benchmark's sans/mono/display as `$value`. Collect unique font names from other findings that differ. Add them to `fallback_stack` in order of source confidence, then append standard system font stack for the category:
- Geometric sans: `-apple-system, BlinkMacSystemFont, "Segoe UI", "Helvetica Neue", sans-serif`
- Mono: `ui-monospace, "JetBrains Mono", "Fira Code", "Cascadia Code", monospace`
- Display: fall through to sans-serif

Type scale: Map observed sizes to standard keys xs/sm/base/lg/xl/2xl/3xl/4xl/5xl. Snap to standard type scale values: 10, 11, 12, 13, 14, 15, 16, 18, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 96. Prefer dominant benchmark's assignment.

Weights: 400/500/600/700 (regular/medium/semibold/bold). Use dominant benchmark's observed weights.

Line heights: Map dominant benchmark's line_height_pattern → tight=1.25, normal=1.5, relaxed=1.625, loose=2.0. Always produce all four entries.

Handle partial failure: If ALL findings have typography=null, produce sensible defaults (system-ui for sans, null for mono/display, standard 16px base scale). Document each default in the token's `$description` field (e.g., `$description: "Generated default — no benchmark contained typography data"`). Do NOT log these in conflict_log — they are not multi-source conflicts.

**10. Step 7: Spacing Merge Pass** — base_unit: Use 4 if any finding used base_unit=4. Use 8 only if ALL findings used 8. Always produce all 13 required scale steps: keys 1,2,3,4,5,6,8,10,12,16,20,24,32. Step N value = N × base_unit, expressed as `"Npx"` string with px suffix.

Semantic spacing: Assign from the dominant benchmark's density:
- compact  → component-gap=scale.2, card-padding=scale.3, page-margin=scale.4, section-padding=scale.6, input-padding=scale.2, stack-gap=scale.1
- comfortable → component-gap=scale.3, card-padding=scale.4, page-margin=scale.6, section-padding=scale.8, input-padding=scale.3, stack-gap=scale.2
- spacious → component-gap=scale.4, card-padding=scale.6, page-margin=scale.8, section-padding=scale.12, input-padding=scale.4, stack-gap=scale.3

Use DTCG reference syntax for semantic values: `"{tokens.spacing.scale.N}"`.

Handle partial failure: If ALL findings have spacing=null, default to 4px base, comfortable density. Document each default in the token's `$description` field (e.g., `$description: "Generated default — no benchmark contained spacing data"`). Do NOT log these in conflict_log — they are not multi-source conflicts.

**11. Step 8: Non-Color Tokens Pass** —
Shadows: Collect all non-null shadow arrays. Merge by elevation tier (sm/md/lg/xl). If multiple sources have a shadow for the same tier, take the dominant benchmark's. Include a tier if ANY source has it (completeness over consensus). Convert findings shadow format (offset_x, offset_y, blur, spread as numbers + color + opacity) to DTCG format (offsetX, offsetY, blur, spread as "Npx" strings, color as 8-digit hex with alpha). If no findings have shadows, output null.

Border radius: Merge by tier (sm/md/lg). Frequency vote per tier. "full" always = "9999px". Convert from numeric pixel values in findings to "Npx" string format.

Opacity: Merge all non-null opacity_scale arrays. Map observed values to named levels: subtle (0.05-0.1), disabled (0.3-0.5), overlay (0.5-0.6), heavy (0.8-0.95). Include a level if seen in any source. If no findings have opacity, output null.

**12. Step 9: Aesthetic Pass** —
density: Frequency vote across all findings. Ties go to dominant benchmark.
tone: Frequency vote. Ties go to dominant benchmark.
personality_tags: Start with dominant benchmark's tags. Add tags from other findings that appear in 2+ sources AND are consistent with the winning tone. Remove tags that contradict the dominant tone (e.g., remove "bold" if tone is "minimal", remove "minimal" if tone is "bold"). Result: 4-8 tags.
summary: 2-3 factual sentences characterizing the dominant aesthetic. Use the structured fields (tone, density, color temperature, roundness) — not opinion or aspiration. Factual description tone, not opinionated narrative.
dominant_approach: One line: "{tone} {surface} with {primary color description}". Example: "Clean minimal SaaS with blue accent and generous whitespace."

CRITICAL: "Pick dominant, don't blend." When benchmarks have mixed aesthetics, pick the dominant direction. Do NOT interpolate enum values. Do NOT produce compromise terms. Remove minority-direction tags.

If source count is evenly split between conflicting aesthetic directions, note this in aesthetic.summary: "Sources represent two distinct aesthetic directions; synthesis based on dominant benchmark."

**13. Step 10: Platform Notes** — Generate platform_notes:
- `react`: Always include: "Use CSS custom properties for color tokens to enable runtime theme switching. Apply --color-*: initial; in @theme to suppress Tailwind defaults. Font fallback stacks should be included in the CSS font-family declarations."
- `swiftui`: Always include: "Reference colors via asset catalog (Color(\"name\", bundle: .module)) for automatic dark mode. Use @ScaledMetric for spacing constants. Minimum deployment target is iOS 16."

**14. Step 11: Fill and Validate** — Fill the output template (embedded below) with all merge pass results. Self-check before writing:
- [ ] All required tokens are present (non-null where required by schema)
- [ ] All hex values match `#RRGGBB` pattern (6 hex digits)
- [ ] All dimension values end in "px"
- [ ] conflict_log is present (empty [] when no multi-source conflicts exist, e.g., N=1 source). Derived tokens are NOT logged in conflict_log — derivations are documented in each token's $description field instead.
- [ ] aesthetic.summary is at least 20 characters
- [ ] personality_tags has 4-8 entries
- [ ] generated_at is a valid ISO 8601 datetime string
- [ ] All 18 semantic color roles have non-null values with $description
- [ ] surface.overlay, surface.inset, text.secondary, text.link are all populated (even if derived)
- [ ] Spacing scale has all 13 required keys
- [ ] Typography scale has all 9 required keys

IMPORTANT: Use JSON literal null (no quotes) for absent values. Never write the string "null".

**15. Step 12: Write Output** — Write the completed JSON to output_path using the Write tool. Do not return until Write succeeds.

**16. Step 13: Return Summary** — Return exactly:
`"Synthesized {N} findings → design-system.json: {dominant_approach}, {conflict_count} conflicts resolved"`

**17. Output Template** — Embed the COMPLETE design-system.json example from token-schema.md Section 7 as the fill-in template. Copy it VERBATIM — do not paraphrase, reorder, abbreviate, or extend it. This is a Phase 1 artifact. Add a note above the template: "Fill this template by replacing all values with the merge pass results. The structure must match exactly — do not add or remove fields."

Verify the completed file:
- Contains the frontmatter with name, description, tools
- Contains all 13 steps in order
- Contains the complete merge algorithm with quantization rules, conflict resolution decision table, derivation table
- Contains the complete findings-to-output mapping table (21 keys)
- Contains dark-mode derivation heuristics
- Contains the full output template from token-schema.md Section 7
- Does not contain any code blocks that are "pseudo-code" — everything is literal JSON or literal prose instructions
- The conflict_log instruction explicitly says "IMMEDIATELY add" during merge — not at the end
- Total line count should be >= 600 lines (template alone is ~260 lines, algorithm + mapping tables + heuristics add ~400+)
  </action>
  <verify>
File exists: `ls skills/dsys/agents/synthesizer.md` succeeds.

Line count: `wc -l skills/dsys/agents/synthesizer.md` should be >= 600 lines.

Key content checks:
- `grep -c "Step" skills/dsys/agents/synthesizer.md` returns at least 13 (the 13 steps)
- `grep -c "conflict_log" skills/dsys/agents/synthesizer.md` returns >= 5 (appears in algorithm, template, validation, examples)
- `grep -c "quantiz" skills/dsys/agents/synthesizer.md` returns >= 3 (quantization rules, examples)
- `grep -c "surface.overlay" skills/dsys/agents/synthesizer.md` returns >= 2 (derivation table + template)
- `grep -c "text.link" skills/dsys/agents/synthesizer.md` returns >= 2 (derivation table + template)
- `grep -c "text.secondary" skills/dsys/agents/synthesizer.md` returns >= 2 (derivation table + template)
- `grep "IMMEDIATELY" skills/dsys/agents/synthesizer.md` confirms the incremental conflict logging instruction
- `grep "Write tool" skills/dsys/agents/synthesizer.md` confirms the write instruction
- `grep "Error:" skills/dsys/agents/synthesizer.md` confirms error message format
- `grep "dominant_approach" skills/dsys/agents/synthesizer.md` returns >= 3 (meta field, aesthetic pass, return summary)
- `grep "personality_tags" skills/dsys/agents/synthesizer.md` returns >= 2 (aesthetic pass, template)
- `grep "action_primary" skills/dsys/agents/synthesizer.md` returns >= 3 (mapping table, derivation, template)
  </verify>
  <done>
`skills/dsys/agents/synthesizer.md` exists with all 13 ordered steps, the complete merge algorithm (quantization, frequency-weighted voting, tiebreaking), the 21-key findings-to-output mapping table, derivation table for 4 missing tokens, dark-mode inference heuristics, self-validation checklist, explicit Write tool instruction, and the full design-system.json fill-in template from token-schema.md. The agent can be invoked by the orchestrator via Task with findings_paths and output_path.
  </done>
</task>

</tasks>

<verification>
1. `skills/dsys/agents/synthesizer.md` exists and is >= 600 lines
2. The agent prompt contains all 13 steps in order (Load → Source Validation → Quantization → Semantic Color → Primitive Color → Typography → Spacing → Non-Color → Aesthetic → Platform Notes → Validate → Write → Return)
3. The agent prompt embeds the complete design-system.json template from token-schema.md Section 7
4. The merge algorithm includes hex quantization (nearest multiple of 16 per channel)
5. The conflict resolution uses frequency-weighted voting with explicit tiebreaker rules
6. The conflict_log is built incrementally ("IMMEDIATELY add") during merge passes for multi-source conflicts only — derived tokens are documented via $description, not conflict_log (satisfies schema minItems:2 constraint on candidates)
7. The derivation table covers all 4 missing tokens: surface.overlay, surface.inset, text.secondary, text.link
8. The dark-mode derivation heuristics cover all semantic keys that have _dark counterparts
9. The aesthetic pass has explicit "pick dominant, don't blend" instruction
10. The agent writes to caller-specified output_path (not hardcoded)
</verification>

<success_criteria>
- A single Markdown agent file exists at `skills/dsys/agents/synthesizer.md` that can be invoked by the orchestrator to merge N findings into a design system
- The agent loads findings, applies the multi-pass merge algorithm, fills the design-system.json template, self-validates, writes output, and returns a summary
- All locked decisions from CONTEXT.md are implemented: frequency-weighted voting, quantize-before-compare, dominant set + extras, 4px grid enforcement, pick dominant aesthetic (don't blend), conflict log with decision only (for multi-source conflicts; derived tokens use $description)
- All Claude's Discretion choices are handled: font family merge (pick one + fallbacks), output to caller-specified path, self-validation before write, 16-step quantization threshold
</success_criteria>

<output>
After completion, create `.planning/phases/03-synthesizer-agent/03-01-SUMMARY.md`
</output>
